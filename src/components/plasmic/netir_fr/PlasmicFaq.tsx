/* eslint-disable */
/* tslint:disable */
// @ts-nocheck
/* prettier-ignore-start */

/** @jsxRuntime classic */
/** @jsx createPlasmicElementProxy */
/** @jsxFrag React.Fragment */

// This class is auto-generated by Plasmic; please do not edit!
// Plasmic Project: oiQgZxfnSVj2maau7x1Bhf
// Component: wBbJjw0EbsaX

import * as React from "react";

import {
  Link,
  GatsbyLinkProps as LinkProps,
  navigate as __gatsbyNavigate
} from "gatsby";

import {
  Flex as Flex__,
  MultiChoiceArg,
  PlasmicDataSourceContextProvider as PlasmicDataSourceContextProvider__,
  PlasmicIcon as PlasmicIcon__,
  PlasmicImg as PlasmicImg__,
  PlasmicLink as PlasmicLink__,
  PlasmicPageGuard as PlasmicPageGuard__,
  SingleBooleanChoiceArg,
  SingleChoiceArg,
  Stack as Stack__,
  StrictProps,
  Trans as Trans__,
  classNames,
  createPlasmicElementProxy,
  deriveRenderOpts,
  ensureGlobalVariants,
  generateOnMutateForSpec,
  generateStateOnChangeProp,
  generateStateOnChangePropForCodeComponents,
  generateStateValueProp,
  get as $stateGet,
  hasVariant,
  initializeCodeComponentStates,
  initializePlasmicStates,
  makeFragment,
  omit,
  pick,
  renderPlasmicSlot,
  set as $stateSet,
  useCurrentUser,
  useDollarState,
  usePlasmicTranslator,
  useTrigger,
  wrapWithClassName
} from "@plasmicapp/react-web";
import {
  DataCtxReader as DataCtxReader__,
  useDataEnv,
  useGlobalActions
} from "@plasmicapp/react-web/lib/host";

import { _useGlobalVariants } from "./plasmic"; // plasmic-import: oiQgZxfnSVj2maau7x1Bhf/projectModule
import { _useStyleTokens } from "./PlasmicStyleTokensProvider"; // plasmic-import: oiQgZxfnSVj2maau7x1Bhf/styleTokensProvider

import "@plasmicapp/react-web/lib/plasmic.css";

import * as projectcss from "./plasmic.module.css"; // plasmic-import: oiQgZxfnSVj2maau7x1Bhf/projectcss
import * as sty from "./PlasmicFaq.module.css"; // plasmic-import: wBbJjw0EbsaX/css

import MinusIcon from "./icons/PlasmicIcon__Minus"; // plasmic-import: Uldb6Z9VLGCA/icon
import _4115237AddPlusIconSvgIcon from "./icons/PlasmicIcon___4115237AddPlusIconSvg"; // plasmic-import: DiXnhJt4CXtf/icon

createPlasmicElementProxy;

export type PlasmicFaq__VariantMembers = {};
export type PlasmicFaq__VariantsArgs = {};
type VariantPropType = keyof PlasmicFaq__VariantsArgs;
export const PlasmicFaq__VariantProps = new Array<VariantPropType>();

export type PlasmicFaq__ArgsType = { question?: string; answer?: string };
type ArgPropType = keyof PlasmicFaq__ArgsType;
export const PlasmicFaq__ArgProps = new Array<ArgPropType>(
  "question",
  "answer"
);

export type PlasmicFaq__OverridesType = {
  root?: Flex__<"div">;
  freeBox?: Flex__<"div">;
  h1?: Flex__<"h1">;
  h5?: Flex__<"h5">;
  text?: Flex__<"div">;
};

export interface DefaultFaqProps {
  question?: string;
  answer?: string;
  className?: string;
}

const $$ = {};

function PlasmicFaq__RenderFunc(props: {
  variants: PlasmicFaq__VariantsArgs;
  args: PlasmicFaq__ArgsType;
  overrides: PlasmicFaq__OverridesType;
  forNode?: string;
}) {
  const { variants, overrides, forNode } = props;

  const args = React.useMemo(
    () =>
      Object.assign(
        {
          question: "Comment fonctionne NoBullshit Tech Engineers ?",
          answer:
            "NoBullshit Tech Engineers (NBTE) est une alliance qui met en relation un collectif de freelances full stack et des entreprises. En int\u00e9grant le collectif en tant que freelance, NBTE te met en relation avec une entreprise cliente o\u00f9 tu exerceras des missions en tant que freelance. Notre objectif est d'aider les entreprises \u00e0 transformer leur informatique en centre de profits gr\u00e2ce \u00e0 la cr\u00e9ation de SaaS mon\u00e9tis\u00e9s, l'am\u00e9lioration de la performance \u00e9conomique de leurs employ\u00e9s via l'int\u00e9gration de l'IA et l'urbanisation de leur SI."
        },
        Object.fromEntries(
          Object.entries(props.args).filter(([_, v]) => v !== undefined)
        )
      ),
    [props.args]
  );

  const $props = {
    ...args,
    ...variants
  };

  const $ctx = useDataEnv?.() || {};
  const refsRef = React.useRef({});
  const $refs = refsRef.current;

  const stateSpecs: Parameters<typeof useDollarState>[0] = React.useMemo(
    () => [
      {
        path: "isOpen",
        type: "private",
        variableType: "boolean",
        initFunc: ({ $props, $state, $queries, $ctx }) => false
      }
    ],
    [$props, $ctx, $refs]
  );
  const $state = useDollarState(stateSpecs, {
    $props,
    $ctx,
    $queries: {},
    $refs
  });

  const styleTokensClassNames = _useStyleTokens();

  return (
    <div
      data-plasmic-name={"root"}
      data-plasmic-override={overrides.root}
      data-plasmic-root={true}
      data-plasmic-for-node={forNode}
      className={classNames(
        projectcss.all,
        projectcss.root_reset,
        projectcss.plasmic_default_styles,
        projectcss.plasmic_mixins,
        styleTokensClassNames,
        sty.root
      )}
    >
      <div
        data-plasmic-name={"freeBox"}
        data-plasmic-override={overrides.freeBox}
        className={classNames(projectcss.all, sty.freeBox)}
        onClick={async event => {
          const $steps = {};

          $steps["updateIsOpen"] = true
            ? (() => {
                const actionArgs = {
                  variable: {
                    objRoot: $state,
                    variablePath: ["isOpen"]
                  },
                  operation: 4
                };
                return (({ variable, value, startIndex, deleteCount }) => {
                  if (!variable) {
                    return;
                  }
                  const { objRoot, variablePath } = variable;

                  const oldValue = $stateGet(objRoot, variablePath);
                  $stateSet(objRoot, variablePath, !oldValue);
                  return !oldValue;
                })?.apply(null, [actionArgs]);
              })()
            : undefined;
          if (
            $steps["updateIsOpen"] != null &&
            typeof $steps["updateIsOpen"] === "object" &&
            typeof $steps["updateIsOpen"].then === "function"
          ) {
            $steps["updateIsOpen"] = await $steps["updateIsOpen"];
          }
        }}
      >
        <h1
          data-plasmic-name={"h1"}
          data-plasmic-override={overrides.h1}
          className={classNames(
            projectcss.all,
            projectcss.h1,
            projectcss.__wab_text,
            sty.h1
          )}
        >
          <React.Fragment>
            <React.Fragment>{""}</React.Fragment>
            {
              <h5
                data-plasmic-name={"h5"}
                data-plasmic-override={overrides.h5}
                className={classNames(
                  projectcss.all,
                  projectcss.h5,
                  projectcss.__wab_text,
                  sty.h5
                )}
              >
                <React.Fragment>
                  {(() => {
                    try {
                      return $props.question;
                    } catch (e) {
                      if (
                        e instanceof TypeError ||
                        e?.plasmicType === "PlasmicUndefinedDataError"
                      ) {
                        return "Comment fonctionne NoBullshit Tech Engineers ?";
                      }
                      throw e;
                    }
                  })()}
                </React.Fragment>
              </h5>
            }
            <React.Fragment>{""}</React.Fragment>
          </React.Fragment>
        </h1>
        {(() => {
          try {
            return $state.isOpen;
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return false;
            }
            throw e;
          }
        })() ? (
          <MinusIcon
            className={classNames(projectcss.all, sty.svg__vW4Ik)}
            role={"img"}
          />
        ) : null}
        {(() => {
          try {
            return !$state.isOpen;
          } catch (e) {
            if (
              e instanceof TypeError ||
              e?.plasmicType === "PlasmicUndefinedDataError"
            ) {
              return false;
            }
            throw e;
          }
        })() ? (
          <_4115237AddPlusIconSvgIcon
            className={classNames(projectcss.all, sty.svg__gToYl)}
            role={"img"}
          />
        ) : null}
      </div>
      {(() => {
        try {
          return $state.isOpen;
        } catch (e) {
          if (
            e instanceof TypeError ||
            e?.plasmicType === "PlasmicUndefinedDataError"
          ) {
            return true;
          }
          throw e;
        }
      })() ? (
        <div
          data-plasmic-name={"text"}
          data-plasmic-override={overrides.text}
          className={classNames(
            projectcss.all,
            projectcss.__wab_text,
            sty.text
          )}
        >
          <div
            className={projectcss.__wab_expr_html_text}
            dangerouslySetInnerHTML={{
              __html: (() => {
                try {
                  return $props.answer;
                } catch (e) {
                  if (
                    e instanceof TypeError ||
                    e?.plasmicType === "PlasmicUndefinedDataError"
                  ) {
                    return "NoBullshit Tech Engineers (NBTE) est une alliance qui met en relation un collectif de freelances full stack et des entreprises. En int\u00e9grant le collectif en tant que freelance, NBTE te met en relation avec une entreprise cliente o\u00f9 tu exerceras des missions en tant que freelance. Notre objectif est d'aider les entreprises \u00e0 transformer leur informatique en centre de profits gr\u00e2ce \u00e0 la cr\u00e9ation de SaaS mon\u00e9tis\u00e9s, l'am\u00e9lioration de la performance \u00e9conomique de leurs employ\u00e9s via l'int\u00e9gration de l'IA et l'urbanisation de leur SI.";
                  }
                  throw e;
                }
              })()
            }}
          />
        </div>
      ) : null}
    </div>
  ) as React.ReactElement | null;
}

const PlasmicDescendants = {
  root: ["root", "freeBox", "h1", "h5", "text"],
  freeBox: ["freeBox", "h1", "h5"],
  h1: ["h1", "h5"],
  h5: ["h5"],
  text: ["text"]
} as const;
type NodeNameType = keyof typeof PlasmicDescendants;
type DescendantsType<T extends NodeNameType> =
  (typeof PlasmicDescendants)[T][number];
type NodeDefaultElementType = {
  root: "div";
  freeBox: "div";
  h1: "h1";
  h5: "h5";
  text: "div";
};

type ReservedPropsType = "variants" | "args" | "overrides";
type NodeOverridesType<T extends NodeNameType> = Pick<
  PlasmicFaq__OverridesType,
  DescendantsType<T>
>;
type NodeComponentProps<T extends NodeNameType> =
  // Explicitly specify variants, args, and overrides as objects
  {
    variants?: PlasmicFaq__VariantsArgs;
    args?: PlasmicFaq__ArgsType;
    overrides?: NodeOverridesType<T>;
  } &
    // Specify variants directly as props
    Omit<PlasmicFaq__VariantsArgs, ReservedPropsType> &
    // Specify args directly as props
    Omit<PlasmicFaq__ArgsType, ReservedPropsType> &
    // Specify overrides for each element directly as props
    Omit<
      NodeOverridesType<T>,
      ReservedPropsType | VariantPropType | ArgPropType
    > &
    // Specify props for the root element
    Omit<
      Partial<React.ComponentProps<NodeDefaultElementType[T]>>,
      ReservedPropsType | VariantPropType | ArgPropType | DescendantsType<T>
    >;

function makeNodeComponent<NodeName extends NodeNameType>(nodeName: NodeName) {
  type PropsType = NodeComponentProps<NodeName> & { key?: React.Key };
  const func = function <T extends PropsType>(
    props: T & StrictProps<T, PropsType>
  ) {
    const { variants, args, overrides } = React.useMemo(
      () =>
        deriveRenderOpts(props, {
          name: nodeName,
          descendantNames: PlasmicDescendants[nodeName],
          internalArgPropNames: PlasmicFaq__ArgProps,
          internalVariantPropNames: PlasmicFaq__VariantProps
        }),
      [props, nodeName]
    );
    return PlasmicFaq__RenderFunc({
      variants,
      args,
      overrides,
      forNode: nodeName
    });
  };
  if (nodeName === "root") {
    func.displayName = "PlasmicFaq";
  } else {
    func.displayName = `PlasmicFaq.${nodeName}`;
  }
  return func;
}

export const PlasmicFaq = Object.assign(
  // Top-level PlasmicFaq renders the root element
  makeNodeComponent("root"),
  {
    // Helper components rendering sub-elements
    freeBox: makeNodeComponent("freeBox"),
    h1: makeNodeComponent("h1"),
    h5: makeNodeComponent("h5"),
    text: makeNodeComponent("text"),

    // Metadata about props expected for PlasmicFaq
    internalVariantProps: PlasmicFaq__VariantProps,
    internalArgProps: PlasmicFaq__ArgProps
  }
);

export default PlasmicFaq;
/* prettier-ignore-end */
